# BFS 
# 가까운 노드부터 우선 탐색하는 알고리즘
# 큐 자료구조 사용
# 소위 최단 경로! 문제에 많이 사용

# 1.시작 노드를 큐에 넣고 방문 처리
# 2.큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 "모두!" 큐에 넣고 방문 처리
# 3.2를 못할 때 까지 반복

# BFS 구현하기
from collections import deque

graph = [
    [],
    [2,3,8],
    [1,7],
    [1,4,5],
    [3,5],
    [3,4],
    [7],
    [2,6,8],
    [1,7]
]

visited = [False] * 9

def bfs(graph, start, visited):
    # 1-1. 큐 생성하고 시작 노드 큐에 삽입
    queue = deque([start])

    # 1-2. 그리고 그 노드 방문처리
    visited[start] = True

    # 반복
    while queue: # 3. 언제까지? 못할 때 까지
        v = queue.popleft() # 2-1. 큐에서 노드 꺼낸 뒤에
        print(v, end = ' ')
        for i in graph[v]: # 2-2. 인접 노드에 대하여
            if not visited[i]: # 2-3. 방문하지 않았다면
                queue.append(i) # 2-4. 큐에 넣고
                visited[i] = True # 2-5. 방문처리해라!

bfs(graph, 1, visited)


# 문제풀이

# 음료수 얼려먹기
    # N * M의 얼음틀이 있다. 구멍이 있는 부분은 0, 칸막이가 있는 부분은 1로 표시된다. 
    # 구멍이 뚫린 부분끼리 상하좌우로 붙어있는 경우, 서로 연결된 것으로 간주한다.
    # 이때 얼음 틀의 모양이 주어졌을 때 생성되는 아이스크림의 개수를 구하는 프로그램을 작성하라.

    # 입력조건
        # 첫째 줄에 N, M이 주어짐. 1<= N,M <= 1000
        # 두번째 줄부터 N+1까지 얼음 틀의 형태
        # 이 때 구멍은 0, 막힌 건 1

    # 출력조건
        # 한 번에 만들 수 있는 아이스크림의 개수 출력 
          
    # 풀이
        # 그래프 형태로 모델링 하여 BFS, DFS로 풀 수 있다!
        # 모든 노드에 대해 D/BFS를 실행해 방문 처리를 하면, 연결된 요소가 몇 개인지 볼 수 있다. 

        # DFS 풀이
            # 1. 특정 지점의 주변 상, 하, 좌, 우를 살펴본 뒤에 주변 지점 중 값이 0이며, 아직 방문하지 않은 지점이 있다면 방문
            # 2. 다시 반복하면 모든 지점 방문 가능.
            # 3. 위의 과정을 반복하며 방문하지 않은 지점의 개수 카운트

# input 정의 (N,M을 공백 기준으로 구분해, 입력 받기)
# n, m = map(int, input().split())
n = 3
m = 3
# graph 정의 (2차원 리스트로 변환)
# graph = []
# for i in range(n):
#     graph.append(list(map(int, input())))

graph = [
    [0,0,1],
    [0,1,0],
    [1,0,1]
]

# dfs 함수 정의
def dfs(x,y):
    # 범위 벗어난 경우, 바로 False 반환
    if x < 0 or x >= n or y < 0 or y >= m:
        return False
    # 1-1.현재 노드를 방문하지 않았다면        
    if graph[x][y] == 0:
        # 1-2.현재 노드를 방문 처리
        graph[x][y] = 1
        # 2. 이후 상하좌우에 연결된 노드들에 대해서도 재귀적 호출!
        dfs(x-1, y)
        dfs(x, y-1)
        dfs(x+1, y)
        dfs(x, y+1) # 이때 이 dfs들은 결과에는 반영되지 않으나, 방문처리를 하며 graph를 변형하는 효과를 가짐.
        # 3. 그리고 새로운 아이스크림을 찾았으니까, 우리는 개수에 +1을 해주면 되는 것이지.
        return True
    # 1-3.현재 노드를 이미 방문했다면 딱히 추가할 필요가 없고, 또 재귀적으로 호출할 필요도 없다. 즉 탐색 종료다.
    return False

# 모든 노드에 음료수 채우기
result = 0
for i in range(n):
    for j in range(m):
        if dfs(i,j) == True:
            result += 1
print(result)

# 미로탈출
    # N * M 크기의 미로에 갇혔고, 미로에는 여러 마리의 괴물이 있어서 이를 피해 탈출해야 한다 (ㄷㄷ) 
    # 동빈이의 현 위치는 (1,1)이며 미로의 출구는 (N,M), 한 번에 한 칸씩 이동할 수 있다. 
    # 이때 괴물이 있으면 0, 없으면 1으로 표시되어있다.
    # 이때 동빈이가 탈출을 위해 움직여야 하는 최소 칸의 개수를 구해라. 첫 칸과 마지막 칸은 모두 횟수에 포함한다.

    # 입력조건
        # 첫째 줄에 N, M이 주어짐. 4<= N,M <= 200
        # 두번째 줄부터 N+1까지 미로의 정보
        # 시작과 마지막 칸은 항상 1

    # 출력조건
        # 최소 이동 칸의 개수 출력!
          
    # 풀이
        # 그래프 형태로 모델링 하여 BFS, DFS로 풀 수 있다!
        # 모든 노드에 대해 D/BFS를 실행해 방문 처리를 하면, 연결된 요소가 몇 개인지 볼 수 있다. 

        # BFS 풀이
            # 시작 지점에서 가까운 노드부터 모든 노드 탐색 후  상, 하, 좌, 우 노드간의 거리가 1로 동일, 따라서 (1,1)에서 BFS를 수행해 모든 노드의 최단 거리값을 기록하면 해결 가능!
            # 1. 시작 지점에 방문 처리
            # 2. 방문이 가능한 곳으로 탐색 후 방문 뒤 새롭게 방문한 노드의 값을 2로 바꿈 즉, 거리를 +1
            # 3. 다시 상하좌우로 재귀하며 거리를 +1 해가고 마지막 자리를 출력하면 그게 최단 경로

# input 정의 (N,M을 공백 기준으로 구분해, 입력 받기)
# n, m = map(int, input().split())
n = 3
m = 3
# graph 정의 (2차원 리스트로 변환)
# graph = []
# for i in range(n):
#     graph.append(list(map(int, input())))
graph = [
    [1,1,0],
    [0,1,0],
    [0,1,1]
]

# 이동할 4가지 방향 정의
dx = [0,0,-1,1]
dy = [1,-1,0,0]

# bfs 구현
def bfs(x, y):
    # 큐 생성
    queue = deque()
    # 1.시작 지점에 방문
    queue.append((x,y))
    while queue:
        # bfs로 할 거니까 빼주고
        x, y = queue.popleft()
        
        # 2-1. 상하좌우로 이동해
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            # 2-2. 공간을 벗어나거나, 괴물을 만나는 경우면 무시하고    
            if nx < 0 or nx >= n or ny < 0 or ny >= m:
                continue
            if graph[nx][ny] == 0:
                continue
            
            # 2-3. 해당 노드가 갈 수 있다면 (처음이라면), 그 전 거리에 +1 하여 최단거리를 그 노드에 기록
            if graph[nx][ny] == 1:
                graph[nx][ny] = graph[x][y] +1

                # 3. 하고 다시 queue에 넣어서 재귀!
                queue.append((nx, ny))
    # 결과는 가장 오른쪽 아래의 노드 = 최단거리
    return graph[n-1][m-1]

print(bfs(0,0))
